// Generated by CoffeeScript 1.3.1

/*
# node-make-sync
# Copyright(c) 2012 Seb Vincent
# MIT Licensed
*/


(function() {
  var Future, Options, makeFuncSync, makeObjSync, makeSync, sync, wait, _callSync,
    __slice = [].slice;

  require('fibers');

  Future = require('fibers/future');

  wait = Future.wait;

  Options = require('../lib/options').Options;

  _callSync = function() {
    var args, f, fWithErr, res, wrappedf;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    fWithErr = function(callback) {
      return f.apply(this, __slice.call(args).concat([function(err, res) {
          var _ref;
          if (res == null) {
            _ref = [null, err], err = _ref[0], res = _ref[1];
          }
          return callback(err, res);
        }]));
    };
    wrappedf = Future.wrap(fWithErr);
    res = wrappedf.apply(this);
    wait(res);
    return res.get();
  };

  makeFuncSync = function(f, options, key) {
    var mode, numOfParams, prepareCall;
    mode = options.mode();
    numOfParams = options.numOfParams(key);
    prepareCall = [][0];
    switch (mode[0]) {
      case 'sync':
        prepareCall = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return ['sync', args];
        };
        break;
      case 'async':
        prepareCall = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return ['async', args];
        };
        break;
      case 'mixed':
        switch (mode[1]) {
          case 'fibers':
            prepareCall = function() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              if (Fiber.current != null) {
                return ['sync', args];
              } else {
                return ['async', args];
              }
            };
            break;
          case 'args':
            prepareCall = function() {
              var args, done, _i;
              args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
              if ((numOfParams != null) && (done != null) && args.length < numOfParams) {
                args.push(done);
                done = void 0;
              }
              if ((done != null) && typeof done !== 'function') {
                args.push(done);
                done = void 0;
              }
              if (done) {
                return ['async', args.concat([done])];
              } else {
                return ['sync', args];
              }
            };
        }
    }
    return function() {
      var args, callMode, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = prepareCall.apply(null, args), callMode = _ref[0], args = _ref[1];
      switch (callMode) {
        case 'sync':
          return _callSync.apply(this, [f].concat(__slice.call(args)));
        case 'async':
          return f.apply(this, __slice.call(args));
      }
    };
  };

  makeObjSync = function(obj, options) {
    var k, v, vSync;
    for (k in obj) {
      v = obj[k];
      if (typeof v === 'function') {
        if (options.isIncluded(k)) {
          vSync = makeFuncSync(v, options, k);
          obj[k] = vSync;
        }
      }
    }
    return obj;
  };

  makeSync = function(target, _options) {
    var options;
    options = new Options(_options);
    switch (typeof target) {
      case 'function':
        return makeFuncSync(target, options);
      case 'object':
        return makeObjSync(target, options);
    }
  };

  sync = function(f) {
    return Fiber(function() {
      return f();
    }).run();
  };

  exports.Sync = sync;

  exports.MakeSync = makeSync;

  exports.MakeObjSync = makeObjSync;

  exports.MakeFuncSync = makeFuncSync;

  exports.sync = sync;

  exports.makeSync = makeSync;

  exports.makeObjSync = makeObjSync;

  exports.makeFuncSync = makeFuncSync;

}).call(this);
